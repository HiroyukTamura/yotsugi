// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'enums.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$VerticalAlignmentTearOff {
  const _$VerticalAlignmentTearOff();

  _VerticalAlignmentBottom bottom() {
    return const _VerticalAlignmentBottom();
  }

  _VerticalAlignmentMiddle middle() {
    return const _VerticalAlignmentMiddle();
  }

  _VerticalAlignmentTop top() {
    return const _VerticalAlignmentTop();
  }
}

/// @nodoc
const $VerticalAlignment = _$VerticalAlignmentTearOff();

/// @nodoc
mixin _$VerticalAlignment {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bottom,
    required TResult Function() middle,
    required TResult Function() top,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bottom,
    TResult Function()? middle,
    TResult Function()? top,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_VerticalAlignmentBottom value) bottom,
    required TResult Function(_VerticalAlignmentMiddle value) middle,
    required TResult Function(_VerticalAlignmentTop value) top,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_VerticalAlignmentBottom value)? bottom,
    TResult Function(_VerticalAlignmentMiddle value)? middle,
    TResult Function(_VerticalAlignmentTop value)? top,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VerticalAlignmentCopyWith<$Res> {
  factory $VerticalAlignmentCopyWith(
          VerticalAlignment value, $Res Function(VerticalAlignment) then) =
      _$VerticalAlignmentCopyWithImpl<$Res>;
}

/// @nodoc
class _$VerticalAlignmentCopyWithImpl<$Res>
    implements $VerticalAlignmentCopyWith<$Res> {
  _$VerticalAlignmentCopyWithImpl(this._value, this._then);

  final VerticalAlignment _value;
  // ignore: unused_field
  final $Res Function(VerticalAlignment) _then;
}

/// @nodoc
abstract class _$VerticalAlignmentBottomCopyWith<$Res> {
  factory _$VerticalAlignmentBottomCopyWith(_VerticalAlignmentBottom value,
          $Res Function(_VerticalAlignmentBottom) then) =
      __$VerticalAlignmentBottomCopyWithImpl<$Res>;
}

/// @nodoc
class __$VerticalAlignmentBottomCopyWithImpl<$Res>
    extends _$VerticalAlignmentCopyWithImpl<$Res>
    implements _$VerticalAlignmentBottomCopyWith<$Res> {
  __$VerticalAlignmentBottomCopyWithImpl(_VerticalAlignmentBottom _value,
      $Res Function(_VerticalAlignmentBottom) _then)
      : super(_value, (v) => _then(v as _VerticalAlignmentBottom));

  @override
  _VerticalAlignmentBottom get _value =>
      super._value as _VerticalAlignmentBottom;
}

/// @nodoc

class _$_VerticalAlignmentBottom implements _VerticalAlignmentBottom {
  const _$_VerticalAlignmentBottom();

  @override
  String toString() {
    return 'VerticalAlignment.bottom()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _VerticalAlignmentBottom);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bottom,
    required TResult Function() middle,
    required TResult Function() top,
  }) {
    return bottom();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bottom,
    TResult Function()? middle,
    TResult Function()? top,
    required TResult orElse(),
  }) {
    if (bottom != null) {
      return bottom();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_VerticalAlignmentBottom value) bottom,
    required TResult Function(_VerticalAlignmentMiddle value) middle,
    required TResult Function(_VerticalAlignmentTop value) top,
  }) {
    return bottom(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_VerticalAlignmentBottom value)? bottom,
    TResult Function(_VerticalAlignmentMiddle value)? middle,
    TResult Function(_VerticalAlignmentTop value)? top,
    required TResult orElse(),
  }) {
    if (bottom != null) {
      return bottom(this);
    }
    return orElse();
  }
}

abstract class _VerticalAlignmentBottom implements VerticalAlignment {
  const factory _VerticalAlignmentBottom() = _$_VerticalAlignmentBottom;
}

/// @nodoc
abstract class _$VerticalAlignmentMiddleCopyWith<$Res> {
  factory _$VerticalAlignmentMiddleCopyWith(_VerticalAlignmentMiddle value,
          $Res Function(_VerticalAlignmentMiddle) then) =
      __$VerticalAlignmentMiddleCopyWithImpl<$Res>;
}

/// @nodoc
class __$VerticalAlignmentMiddleCopyWithImpl<$Res>
    extends _$VerticalAlignmentCopyWithImpl<$Res>
    implements _$VerticalAlignmentMiddleCopyWith<$Res> {
  __$VerticalAlignmentMiddleCopyWithImpl(_VerticalAlignmentMiddle _value,
      $Res Function(_VerticalAlignmentMiddle) _then)
      : super(_value, (v) => _then(v as _VerticalAlignmentMiddle));

  @override
  _VerticalAlignmentMiddle get _value =>
      super._value as _VerticalAlignmentMiddle;
}

/// @nodoc

class _$_VerticalAlignmentMiddle implements _VerticalAlignmentMiddle {
  const _$_VerticalAlignmentMiddle();

  @override
  String toString() {
    return 'VerticalAlignment.middle()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _VerticalAlignmentMiddle);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bottom,
    required TResult Function() middle,
    required TResult Function() top,
  }) {
    return middle();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bottom,
    TResult Function()? middle,
    TResult Function()? top,
    required TResult orElse(),
  }) {
    if (middle != null) {
      return middle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_VerticalAlignmentBottom value) bottom,
    required TResult Function(_VerticalAlignmentMiddle value) middle,
    required TResult Function(_VerticalAlignmentTop value) top,
  }) {
    return middle(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_VerticalAlignmentBottom value)? bottom,
    TResult Function(_VerticalAlignmentMiddle value)? middle,
    TResult Function(_VerticalAlignmentTop value)? top,
    required TResult orElse(),
  }) {
    if (middle != null) {
      return middle(this);
    }
    return orElse();
  }
}

abstract class _VerticalAlignmentMiddle implements VerticalAlignment {
  const factory _VerticalAlignmentMiddle() = _$_VerticalAlignmentMiddle;
}

/// @nodoc
abstract class _$VerticalAlignmentTopCopyWith<$Res> {
  factory _$VerticalAlignmentTopCopyWith(_VerticalAlignmentTop value,
          $Res Function(_VerticalAlignmentTop) then) =
      __$VerticalAlignmentTopCopyWithImpl<$Res>;
}

/// @nodoc
class __$VerticalAlignmentTopCopyWithImpl<$Res>
    extends _$VerticalAlignmentCopyWithImpl<$Res>
    implements _$VerticalAlignmentTopCopyWith<$Res> {
  __$VerticalAlignmentTopCopyWithImpl(
      _VerticalAlignmentTop _value, $Res Function(_VerticalAlignmentTop) _then)
      : super(_value, (v) => _then(v as _VerticalAlignmentTop));

  @override
  _VerticalAlignmentTop get _value => super._value as _VerticalAlignmentTop;
}

/// @nodoc

class _$_VerticalAlignmentTop implements _VerticalAlignmentTop {
  const _$_VerticalAlignmentTop();

  @override
  String toString() {
    return 'VerticalAlignment.top()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _VerticalAlignmentTop);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bottom,
    required TResult Function() middle,
    required TResult Function() top,
  }) {
    return top();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bottom,
    TResult Function()? middle,
    TResult Function()? top,
    required TResult orElse(),
  }) {
    if (top != null) {
      return top();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_VerticalAlignmentBottom value) bottom,
    required TResult Function(_VerticalAlignmentMiddle value) middle,
    required TResult Function(_VerticalAlignmentTop value) top,
  }) {
    return top(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_VerticalAlignmentBottom value)? bottom,
    TResult Function(_VerticalAlignmentMiddle value)? middle,
    TResult Function(_VerticalAlignmentTop value)? top,
    required TResult orElse(),
  }) {
    if (top != null) {
      return top(this);
    }
    return orElse();
  }
}

abstract class _VerticalAlignmentTop implements VerticalAlignment {
  const factory _VerticalAlignmentTop() = _$_VerticalAlignmentTop;
}

/// @nodoc
class _$HorizontalAlignmentTearOff {
  const _$HorizontalAlignmentTearOff();

  _HorizontalAlignmentRight right() {
    return const _HorizontalAlignmentRight();
  }

  _HorizontalAlignmentMiddle middle() {
    return const _HorizontalAlignmentMiddle();
  }

  _HorizontalAlignmentLeft left() {
    return const _HorizontalAlignmentLeft();
  }
}

/// @nodoc
const $HorizontalAlignment = _$HorizontalAlignmentTearOff();

/// @nodoc
mixin _$HorizontalAlignment {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() right,
    required TResult Function() middle,
    required TResult Function() left,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? right,
    TResult Function()? middle,
    TResult Function()? left,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_HorizontalAlignmentRight value) right,
    required TResult Function(_HorizontalAlignmentMiddle value) middle,
    required TResult Function(_HorizontalAlignmentLeft value) left,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_HorizontalAlignmentRight value)? right,
    TResult Function(_HorizontalAlignmentMiddle value)? middle,
    TResult Function(_HorizontalAlignmentLeft value)? left,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HorizontalAlignmentCopyWith<$Res> {
  factory $HorizontalAlignmentCopyWith(
          HorizontalAlignment value, $Res Function(HorizontalAlignment) then) =
      _$HorizontalAlignmentCopyWithImpl<$Res>;
}

/// @nodoc
class _$HorizontalAlignmentCopyWithImpl<$Res>
    implements $HorizontalAlignmentCopyWith<$Res> {
  _$HorizontalAlignmentCopyWithImpl(this._value, this._then);

  final HorizontalAlignment _value;
  // ignore: unused_field
  final $Res Function(HorizontalAlignment) _then;
}

/// @nodoc
abstract class _$HorizontalAlignmentRightCopyWith<$Res> {
  factory _$HorizontalAlignmentRightCopyWith(_HorizontalAlignmentRight value,
          $Res Function(_HorizontalAlignmentRight) then) =
      __$HorizontalAlignmentRightCopyWithImpl<$Res>;
}

/// @nodoc
class __$HorizontalAlignmentRightCopyWithImpl<$Res>
    extends _$HorizontalAlignmentCopyWithImpl<$Res>
    implements _$HorizontalAlignmentRightCopyWith<$Res> {
  __$HorizontalAlignmentRightCopyWithImpl(_HorizontalAlignmentRight _value,
      $Res Function(_HorizontalAlignmentRight) _then)
      : super(_value, (v) => _then(v as _HorizontalAlignmentRight));

  @override
  _HorizontalAlignmentRight get _value =>
      super._value as _HorizontalAlignmentRight;
}

/// @nodoc

class _$_HorizontalAlignmentRight implements _HorizontalAlignmentRight {
  const _$_HorizontalAlignmentRight();

  @override
  String toString() {
    return 'HorizontalAlignment.right()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _HorizontalAlignmentRight);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() right,
    required TResult Function() middle,
    required TResult Function() left,
  }) {
    return right();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? right,
    TResult Function()? middle,
    TResult Function()? left,
    required TResult orElse(),
  }) {
    if (right != null) {
      return right();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_HorizontalAlignmentRight value) right,
    required TResult Function(_HorizontalAlignmentMiddle value) middle,
    required TResult Function(_HorizontalAlignmentLeft value) left,
  }) {
    return right(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_HorizontalAlignmentRight value)? right,
    TResult Function(_HorizontalAlignmentMiddle value)? middle,
    TResult Function(_HorizontalAlignmentLeft value)? left,
    required TResult orElse(),
  }) {
    if (right != null) {
      return right(this);
    }
    return orElse();
  }
}

abstract class _HorizontalAlignmentRight implements HorizontalAlignment {
  const factory _HorizontalAlignmentRight() = _$_HorizontalAlignmentRight;
}

/// @nodoc
abstract class _$HorizontalAlignmentMiddleCopyWith<$Res> {
  factory _$HorizontalAlignmentMiddleCopyWith(_HorizontalAlignmentMiddle value,
          $Res Function(_HorizontalAlignmentMiddle) then) =
      __$HorizontalAlignmentMiddleCopyWithImpl<$Res>;
}

/// @nodoc
class __$HorizontalAlignmentMiddleCopyWithImpl<$Res>
    extends _$HorizontalAlignmentCopyWithImpl<$Res>
    implements _$HorizontalAlignmentMiddleCopyWith<$Res> {
  __$HorizontalAlignmentMiddleCopyWithImpl(_HorizontalAlignmentMiddle _value,
      $Res Function(_HorizontalAlignmentMiddle) _then)
      : super(_value, (v) => _then(v as _HorizontalAlignmentMiddle));

  @override
  _HorizontalAlignmentMiddle get _value =>
      super._value as _HorizontalAlignmentMiddle;
}

/// @nodoc

class _$_HorizontalAlignmentMiddle implements _HorizontalAlignmentMiddle {
  const _$_HorizontalAlignmentMiddle();

  @override
  String toString() {
    return 'HorizontalAlignment.middle()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _HorizontalAlignmentMiddle);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() right,
    required TResult Function() middle,
    required TResult Function() left,
  }) {
    return middle();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? right,
    TResult Function()? middle,
    TResult Function()? left,
    required TResult orElse(),
  }) {
    if (middle != null) {
      return middle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_HorizontalAlignmentRight value) right,
    required TResult Function(_HorizontalAlignmentMiddle value) middle,
    required TResult Function(_HorizontalAlignmentLeft value) left,
  }) {
    return middle(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_HorizontalAlignmentRight value)? right,
    TResult Function(_HorizontalAlignmentMiddle value)? middle,
    TResult Function(_HorizontalAlignmentLeft value)? left,
    required TResult orElse(),
  }) {
    if (middle != null) {
      return middle(this);
    }
    return orElse();
  }
}

abstract class _HorizontalAlignmentMiddle implements HorizontalAlignment {
  const factory _HorizontalAlignmentMiddle() = _$_HorizontalAlignmentMiddle;
}

/// @nodoc
abstract class _$HorizontalAlignmentLeftCopyWith<$Res> {
  factory _$HorizontalAlignmentLeftCopyWith(_HorizontalAlignmentLeft value,
          $Res Function(_HorizontalAlignmentLeft) then) =
      __$HorizontalAlignmentLeftCopyWithImpl<$Res>;
}

/// @nodoc
class __$HorizontalAlignmentLeftCopyWithImpl<$Res>
    extends _$HorizontalAlignmentCopyWithImpl<$Res>
    implements _$HorizontalAlignmentLeftCopyWith<$Res> {
  __$HorizontalAlignmentLeftCopyWithImpl(_HorizontalAlignmentLeft _value,
      $Res Function(_HorizontalAlignmentLeft) _then)
      : super(_value, (v) => _then(v as _HorizontalAlignmentLeft));

  @override
  _HorizontalAlignmentLeft get _value =>
      super._value as _HorizontalAlignmentLeft;
}

/// @nodoc

class _$_HorizontalAlignmentLeft implements _HorizontalAlignmentLeft {
  const _$_HorizontalAlignmentLeft();

  @override
  String toString() {
    return 'HorizontalAlignment.left()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _HorizontalAlignmentLeft);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() right,
    required TResult Function() middle,
    required TResult Function() left,
  }) {
    return left();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? right,
    TResult Function()? middle,
    TResult Function()? left,
    required TResult orElse(),
  }) {
    if (left != null) {
      return left();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_HorizontalAlignmentRight value) right,
    required TResult Function(_HorizontalAlignmentMiddle value) middle,
    required TResult Function(_HorizontalAlignmentLeft value) left,
  }) {
    return left(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_HorizontalAlignmentRight value)? right,
    TResult Function(_HorizontalAlignmentMiddle value)? middle,
    TResult Function(_HorizontalAlignmentLeft value)? left,
    required TResult orElse(),
  }) {
    if (left != null) {
      return left(this);
    }
    return orElse();
  }
}

abstract class _HorizontalAlignmentLeft implements HorizontalAlignment {
  const factory _HorizontalAlignmentLeft() = _$_HorizontalAlignmentLeft;
}
